#!/bin/bash
set -e

# Upload MinimalToken DAR to Canton LocalNet participants
# Auto-detects version from daml.yaml and updates package configuration
#
# Usage:
#   ./scripts/upload_dar.sh [version]
#
# If version is not provided, it will be read from daml.yaml

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
DAML_PROJECT="$PROJECT_ROOT/daml/minimal-token"
DAML_YAML="$DAML_PROJECT/daml.yaml"
CONFIG_FILE="$PROJECT_ROOT/src/config/packageConfig.js"

# Colors for output
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Helper functions
log_info() {
    echo -e "${BLUE}$1${NC}"
}

log_success() {
    echo -e "${GREEN}$1${NC}"
}

log_warning() {
    echo -e "${YELLOW}$1${NC}"
}

log_error() {
    echo -e "${RED}$1${NC}"
}

# Read version from daml.yaml
read_version_from_yaml() {
    if [ ! -f "$DAML_YAML" ]; then
        log_error "‚ùå daml.yaml not found at: $DAML_YAML"
        exit 1
    fi

    # Extract version using grep and awk
    VERSION=$(grep "^version:" "$DAML_YAML" | awk '{print $2}' | tr -d '"' | tr -d "'")
    
    if [ -z "$VERSION" ]; then
        log_error "‚ùå Could not find 'version' field in daml.yaml"
        exit 1
    fi

    echo "$VERSION"
}

# Get DAR file path
get_dar_path() {
    local version=$1
    echo "$DAML_PROJECT/.daml/dist/minimal-token-${version}.dar"
}

# Upload DAR to a participant
upload_dar_to_participant() {
    local participant_name=$1
    local port=$2
    local dar_b64=$3
    local version=$4

    log_info "üöÄ Uploading to $participant_name (localhost:$port)..."

    local upload_request=$(cat <<EOF
{
  "dars": [{
    "bytes": "$dar_b64",
    "description": "MinimalToken v${version} - ProposeBurn/AcceptBurn pattern"
  }],
  "vet_all_packages": true,
  "synchronize_vetting": true
}
EOF
)

    local result=$(grpcurl -plaintext -d "$upload_request" \
        "localhost:$port" \
        com.digitalasset.canton.admin.participant.v30.PackageService/UploadDar 2>&1)

    if [ $? -ne 0 ]; then
        log_error "‚ùå $participant_name upload failed"
        echo "$result"
        exit 1
    fi

    log_success "‚úÖ $participant_name upload successful"
    echo "$result"
}

# Vet DAR on a participant
vet_dar_on_participant() {
    local participant_name=$1
    local port=$2
    local package_id=$3

    log_info "  üîí Vetting on $participant_name..."

    local vet_request=$(cat <<EOF
{
  "main_package_id": "$package_id",
  "synchronize": true
}
EOF
)

    local result=$(grpcurl -plaintext -d "$vet_request" \
        "localhost:$port" \
        com.digitalasset.canton.admin.participant.v30.PackageService/VetDar 2>&1)

    if [ $? -ne 0 ]; then
        log_warning "  ‚ö†Ô∏è  $participant_name vetting warning: $result"
    else
        log_success "  ‚úÖ $participant_name vetting successful"
    fi
}

# Extract package ID from upload response
extract_package_id() {
    local response=$1
    # Extract JSON portion - strip color codes and get the JSON block
    # Use awk to find lines between { and } inclusive
    echo "$response" | sed 's/\x1b\[[0-9;]*m//g' | awk '/^{/,/^}/' | jq -r '.darIds[0] // empty'
}

# Update package configuration
update_package_config() {
    local package_id=$1
    local version=$2

    log_info ""
    log_info "üìù Updating package configuration: $CONFIG_FILE"

    # Read existing config if it exists
    local versions_entries=()
    if [ -f "$CONFIG_FILE" ]; then
        # Extract existing version entries using sed (macOS compatible)
        while IFS= read -r line; do
            if [[ "$line" =~ \'([^\']+)\':[[:space:]]*\'([^\']+)\' ]]; then
                local v="${BASH_REMATCH[1]}"
                local pid="${BASH_REMATCH[2]}"
                if [ "$v" != "$version" ]; then
                    versions_entries+=("$v:$pid")
                fi
            fi
        done < "$CONFIG_FILE"
    fi

    # Add new version at the beginning (newest first)
    versions_entries=("$version:$package_id" "${versions_entries[@]}")

    # Format for JS object
    local versions_formatted=""
    for i in "${!versions_entries[@]}"; do
        IFS=: read -r v pid <<< "${versions_entries[$i]}"
        versions_formatted+="    '${v}': '${pid}'"
        if [ $i -lt $((${#versions_entries[@]} - 1)) ]; then
            versions_formatted+=",\n"
        fi
    done

    # Create new config file
    cat > "$CONFIG_FILE" <<EOF
// MinimalToken Package Configuration
// This file is auto-generated by upload_dar.sh

export const MINIMAL_TOKEN_PACKAGE_CONFIG = {
  // Current active version
  currentVersion: '${version}',
  currentPackageId: '${package_id}',

  // All deployed versions (newest first)
  versions: {
$(echo -e "$versions_formatted")
  }
};

export default MINIMAL_TOKEN_PACKAGE_CONFIG;
EOF

    log_success "‚úÖ Updated package configuration"
    log_info "   Current version: $version"
    log_info "   Package ID: $package_id"
}

# Main execution
main() {
    log_info "üöÄ Canton DAR Upload Tool"
    echo ""

    # Get version from command line or daml.yaml
    if [ $# -gt 1 ]; then
        echo "Usage: $0 [version]"
        echo ""
        echo "If version is not provided, it will be read from daml.yaml"
        echo ""
        echo "Examples:"
        echo "  $0              # Auto-detect from daml.yaml"
        echo "  $0 1.0.0        # Use specific version"
        exit 1
    fi

    if [ $# -eq 1 ]; then
        VERSION=$1
        log_info "üìù Using version from command line"
    else
        log_info "üìù Reading version from daml.yaml..."
        VERSION=$(read_version_from_yaml)
        log_success "‚úÖ Found version: $VERSION"
    fi

    DAR_PATH=$(get_dar_path "$VERSION")

    echo ""
    log_info "üì¶ Version: $VERSION"
    log_info "üìÅ DAR path: $DAR_PATH"
    echo ""

    # Check if DAR file exists
    if [ ! -f "$DAR_PATH" ]; then
        log_error "‚ùå DAR file not found: $DAR_PATH"
        log_warning "üí° Did you run 'daml build' first?"
        echo ""
        echo "To build:"
        echo "  cd daml/minimal-token"
        echo "  daml build"
        exit 1
    fi

    # Read and encode DAR file
    log_info "üì¶ Reading DAR file: $DAR_PATH"
    DAR_B64=$(base64 -i "$DAR_PATH")
    DAR_SIZE=$(wc -c < "$DAR_PATH" | tr -d ' ')
    log_success "‚úÖ Encoded DAR file ($DAR_SIZE bytes)"
    echo ""

    # Upload to app-provider (port 3902)
    UPLOAD_RESPONSE=$(upload_dar_to_participant "app-provider" "3902" \
        "$DAR_B64" "$VERSION")
    
    # Extract package ID from response
    PACKAGE_ID=$(extract_package_id "$UPLOAD_RESPONSE")
    
    if [ -z "$PACKAGE_ID" ]; then
        log_error "‚ùå Could not extract package ID from response"
        exit 1
    fi
    
    log_success "üì¶ Package ID: $PACKAGE_ID"
    echo ""

    # Upload to app-user (port 2902)
    upload_dar_to_participant "app-user" "2902" "$DAR_B64" "$VERSION" \
        > /dev/null
    echo ""

    # Vet on both participants
    log_info "üîí Vetting DAR on participants..."
    vet_dar_on_participant "app-provider" "3902" "$PACKAGE_ID"
    vet_dar_on_participant "app-user" "2902" "$PACKAGE_ID"
    log_success "‚úÖ DAR vetting complete"

    # Update package configuration
    update_package_config "$PACKAGE_ID" "$VERSION"

    echo ""
    log_success "‚úÖ Upload complete!"
    echo ""
    log_info "üìù Configuration updated automatically in:"
    log_info "   - src/config/packageConfig.js"
    echo ""
    log_info "üí° Make sure your services import from packageConfig.js"
    log_info "   to use the new version"
}

# Run main function
main "$@"

